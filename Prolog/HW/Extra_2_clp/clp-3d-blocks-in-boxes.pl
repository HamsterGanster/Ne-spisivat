/*
 * Трехмерная версия задачи "блоки в коробках".
 * Мы продолжаем использовать предопределенные блоки вместо
 * получения их в качестве параметров командной строки, потому что
 * это в данный момент не имеет значения.
 */

 :- use_module(library(clpr)).

 :- op(400, xfx, inside).
 
 
 % Блоки
 % Теперь блоки имеют не только ширину и высоту, но и размер по оси Z.
 % Давайте обозначим размеры блоков как _x, _y и _z.
 block(b1, d(1.0, 3.0, 2.0)).
 block(b2, d(2.0, 2.0, 1.0)).
 block(b3, d(2.0, 1.0, 1.0)).
 block(b4, d(2.0, 1.0, 1.0)).
 block(b5, d(1.0, 1.0, 1.0)).
 block(b6, d(1.0, 1.0, 1.0)).
 block(b7, d(1.0, 1.0, 1.0)).
 block(b8, d(1.0, 1.0, 1.0)).
 
 % Коробки
 
 box(box1, d(6.0, 6.0, 6.0)).
 box(box2, d(3.0, 3.0, 2.0)).
 
 % rot(?Rect, ?RotatedRect)
 % Поворот прямоугольника в трехмерном пространстве
 %
 % Повороты ZX и YX имеют избыточные ограничения 
 % _y =\= _z, которые необходимы для отсечения ненужных 
 % обратных вызовов. Рассмотрим следующий пример:
 %
 % rot(_, d(2, 1, 1), R).
 % Существует только 3 различных поворота:
 % R = (2, 1, 1)
 % R = (1, 2, 1)
 % R = (1, 1, 2)
 % Но без избыточности ограничений правила поворота могли бы возвращать 
 % избыточные решения, которые уже были возвращены предыдущими правилами.
 
 
 % <YOUR CODE HERE>
 
 
 % Размещение блока в коробке, что означает назначение минимального прямоугольника,
 % который вмещает блок.
 % place_block(+BlockName, -Place).
 % Place = rect(Pos, Dim).
 
 
 % <YOUR CODE HERE>
 
 
 % inside(+Rect1, +Rect2)
 % Предикат выполняется тогда и только тогда, когда Rect1 полностью находится внутри Rect2
 
 
 % <YOUR CODE HERE>
 
 
 % no_overlap(+Rect1, +Rect2)
 % Выполняется тогда и только тогда, когда Rect1 и Rect2 не пересекаются
 %
 % Обратите внимание, что мы добавили избыточные ограничения,
 % чтобы предотвратить ненужные обратные вызовы. Это лучше,
 % чем добавление cuts, потому что они разрушают 
 % декларативную семантику ограничений.
 
 
 % <YOUR CODE HERE>
 