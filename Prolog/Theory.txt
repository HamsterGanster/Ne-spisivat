Семинар 1. Введение:

vars: X or _x (с заглавной, или с подчёркивания)
atom: cesar or 'Cesar' (с маленькой или в одинарных ковычках)
strs: "some string" (в двойных кавычках)

X = 1+1 [x равен двум? Нееет, X - терм с функтором + и двумя аргументами]
X = f(x1, xw2, x3, ... xn)
    | \____ n термов ____/
    |
 функтор

Любое выражение оканчивается точкой.

%              комментарий однострочный
:-             импликация
?-             показать всех (нажать Enter — стоп, пробел — следующий)
,              И (конъюкция)
;              ИЛИ (дизюнкция)
diff(A, B)     A и B должны быть различными (A != B)
A = B          A равно B, строго и полностью
 

Задаём факты (термы): 
  female('Ann')
  male('Tom') 
  female('Robert')
  ...

  parent('Tom', 'Robert')    # Tom родитель Robert'а
  ...

mother(M, C) :- female(M), parent(M, C).                            # mother(Mother, children).  M есть женщина И M родитель для C.
sister(S, C) :- female(S), parent(P, S), parent(P, C), diff(S, C).  # Sister женщина, Parent родитель для S, Parent родитель для Child, S != C (P и P равны, так как это исчесления предикатов)
aunt(A, C)   :- parent(P, C), sister(A, P)                          # Parent родитель для Child И Aunt сестра для Parent


===============================
===============================
===============================


Семинар 2. Списки:

Примерно как в Haskell: (1, (2, (3...))). 
Но можно указывать и [1,2,3...]

L = [H1 | T]
L = [H1, H2 | T]

Псевдо-функции (на примерах):
?- member(0, [1,2,3,4]). % — логическое выражение, НЕ ФУНКЦИЯ.
false.

?- member(1, [1,2,3,4]). % 
true.

?- member(1, L).
% может выдать inf списков:
L = [1 | _508];
L = [_506, 1 | _514];
L = [_506, _512, 1 | _520];
...

?- member(1, [1,2,3,1]).
true;
true.

?- memberchk(1, [1,2,3,1]).
true. % просто содержиться.

Наша реализация:
mem(X, [X | _]).
mem(X, [_ | Tail]) :- mem(X, Tail).

?- L = [_,_,_], mem(a,L), mem(b,L), mem(c,L).
% все 6 варинатов, как и должно быть.

?- append([a,b], [c], L).
L = [a,b,c].

cat([], L, L).
cat([X | Tail], L, [X | Answer]) :- cat(Tail, L, Answer).

% [1,2,3,4,5] полуичть [1,2]
?- L = [1,2,3,4,5], cat(L1, [_,_,_], L).

Подсписок:
% [__L1__|____S___|___L2____]
subList(S, L) :- cat(_, TMP, L), cat(S, _, TMP).
% ____|__S___
% ____TMP____|_____
% ________L________


shiftLeft([], []).
shiftLeft([X], [X]).
shiftLeft([X | Tail], S) :- cat(Tail, [X], S).
?- shiftLeft([1,2,3], S).
[2,3,1].

shiftLeft([], []).
% shiftLeft([X], [X]).
shiftLeft([X | Tail], S) :- cat(Tail, [X], S).

% rev(Cur, Buf, Res).
rev([], Buf, Buf).
% rev([X], Buf, [Buf | X]). % вызывает дичь..
rev([X | Xs], Buf, Res) :- rev(Xs, [X | Buf], Res).

D = f{a:1, b:2, c:3}.
D = f{a:1, b:2, c:3}, D.a. % выведи D.a
D = 

L = X-Y-Z, X=a, Y=b, Z=c.
L= a-b-c, 
X=a, 
Y=b, 
Z=c.


Д/З: 
https://el.nsu.ru/mod/assign/view.php?id=103033
M-R-P-C
месяц-название реактора-принцип-страна


===============================
===============================
===============================


Семинар 3:
Иногда нужно доказать либо 1, либо 2

P = G1, G2, ... Gk ! G(k+1) ... Gn
P = G1, G2 ! G3, G4
Как я понял: в примере сначала пытаемся доказать G1 и G2, если смогли. G3 и G4 не важны. 




%Вспомним семинар 2:
mem(X, [X | _]).
mem(X, [_ | Tail]) :- mem(X, Tail).

% Наш memberchk, используя так называемый "cut".
mm(X, [X | _]) :- !. % Если true, останавливаем рекурсию. 
mm(X, [_ | Tail]) :- mem(X, Tail).


P :- D1; D2.
% и аналогично
P :- D1.
P :- D2.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is — логическй терм.
% не рекомендуют
is (X, *(2,2)). 
% БАН. Не будет работать, так как в Prolog запрещены неопределённые значения справа -> не решает уравнения.
4 is *(X, 2). 

use_module().
use_module(clpfd). 
% Но так как это стандартная библиотека, обернём в library.
use_module(library(clpfd)). % ищет в своих папках, знает где.

% Добавляются операции сравнения (начинаются с решётки)
?- X #= 2*2
X = 4.

?- 4 #= X*2.
X = 2.

?- X#> 0, X #<= 5.
X in 1..5.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Графы:
ab ac 
bd 
cd cf 
de df

добавим fa — появился цикл.

Можем ограничить длину пути N (кол-вом вершин).

Ещё нужно выводить путь. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Семантическая связь, синонимы и т.д. и т.п.
Например, клавиатура и мышь связаны — ~компухтерное~ компьютерное, белка и мышь связаны — животные.

гиперонимия (транспорт гипероним машины, млекопитающее гиперонима ежа)

минероминия (part и member)
  member: член команды (больше к живому)
  part: колесо — часть машины

Будет:
  w1/PoS1/Sen1 и w2/PoS2/Sen2
  _   ?    ?     _   ?    ?
Как связаны w1 и w2? 
Составляем цепочку семантических связей: 
  w1 - ... - w11  и  w11 - ... - w2



Свои предикаты
Алексей Сергеевич объявил свои предикаты (как в Haskell ❤)
  Было:  p(a1, a2)
  Стало: a1 p a2
Где p — предикат или оператор.

Например, 1+2+3 — это 
  +(1, +(2,3)) или
  +(+(1,2), 3)?

У кого бОльший приоритет, тот вычисляется первым.
Но в Prolog по-другому: 
  приоритет больше у внешнего, 
  приоритет меньше — внутренний.

yfx — левая  ассоциативность.
xfy — правая ассоциативность.
xfx — оператор не имеет ассоциативности. 
  Например, '1==2==3' нельзя 😥. 
  '1 =< X =< 3' тоже не имеет смысла, ведь ни '(1 =< X) =< 3', ни '1 =< (X =< 3)' не имеют смысла в Prolog.

У констант приоритет меньше 
x — приоритет строго <  меньше приоритета оператора
y — приоритет меньше <= либо равен приоритета оператора

Арфмитические операторы обычно ЛЕВОассоциатинв.
  Кроме степени ^, ведь x^y^z = x^(y^z) а не (x^y)^z

2+3*4
+(2, *(3,4))

:   для записи времени (18:35).
at  для place - time. 'Riva' at 18:35.

D .= 15:00 .- 13:20
% D = 100 (минут)


trip(PlaceTime1, PlaceTime2)
true если можем последовательно попасть из P1 в P2. То есть в массиве они идут подряд.


Немного текста со stackoverflow ():
  xfy это операция, у которой источник находится слева, а цель - справа. xfx это операция, у которой источник находится слева, а источник - справа. yfx это операция, у которой цель находится слева, а источник - справа.
  
  'xfy' (обычно) ассоциируется с:
    слева направо
    сверху вниз
    Доминирование
    быть первым
    декларативность
    незнание 'yfx'
  'xfx' (обычно) ассоциируется с:
    оценка операндов
    сравнение объектов равного класса
    это все, что у меня есть для этого чудака
  'yfx' (обычно) ассоциируется с:
    справа налево
    снизу вверх
    равноправный
    быть последним (таким образом, в конечном итоге достигается истинное доминирование)
    является процедурным
    терпимость к проделкам 'xfy'
  
  Обратите внимание, что следующее работает, потому что "x" и "y" являются партнерами во всем:
    xfy xfx yfx
  но, напротив, это не работает:
    yfx xfx xfy

