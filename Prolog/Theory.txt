Семинар 1. Введение:

vars: X or _x (с заглавной, или с подчёркивания)
atom: cesar or 'Cesar' (с маленькой или в одинарных ковычках)
strs: "some string" (в двойных кавычках)

X = 1+1 [x равен двум? Нееет, X - терм с функтором + и двумя аргументами]
X = f(x1, xw2, x3, ... xn)
    | \____ n термов ____/
    |
 функтор

Любое выражение оканчивается точкой.

%              комментарий однострочный
:-             импликация
?-             показать всех (нажать Enter — стоп, пробел — следующий)
,              И (конъюкция)
;              ИЛИ (дизюнкция)
diff(A, B)     A и B должны быть различными (A != B)
A = B          A равно B, строго и полностью
 

Задаём факты (термы): 
  female('Ann')
  male('Tom') 
  female('Robert')
  ...

  parent('Tom', 'Robert')    # Tom родитель Robert'а
  ...

mother(M, C) :- female(M), parent(M, C).                            # mother(Mother, children).  M есть женщина И M родитель для C.
sister(S, C) :- female(S), parent(P, S), parent(P, C), diff(S, C).  # Sister женщина, Parent родитель для S, Parent родитель для Child, S != C (P и P равны, так как это исчесления предикатов)
aunt(A, C)   :- parent(P, C), sister(A, P)                          # Parent родитель для Child И Aunt сестра для Parent


===============================
===============================
===============================


Семинар 2. Списки:

Примерно как в Haskell: (1, (2, (3...))). 
Но можно указывать и [1,2,3...]

L = [H1 | T]
L = [H1, H2 | T]

Псевдо-функции (на примерах):
?- member(0, [1,2,3,4]). % — логическое выражение, НЕ ФУНКЦИЯ.
false.

?- member(1, [1,2,3,4]). % 
true.

?- member(1, L).
% может выдать inf списков:
L = [1 | _508];
L = [_506, 1 | _514];
L = [_506, _512, 1 | _520];
...

?- member(1, [1,2,3,1]).
true;
true.

?- memberchk(1, [1,2,3,1]).
true. % просто содержиться.

Наша реализация:
mem(X, [X | _]).
mem(X, [_ | Tail]) :- mem(X, Tail).

?- L = [_,_,_], mem(a,L), mem(b,L), mem(c,L).
% все 6 варинатов, как и должно быть.

?- append([a,b], [c], L).
L = [a,b,c].

cat([], L, L).
cat([X | Tail], L, [X | Answer]) :- cat(Tail, L, Answer).

% [1,2,3,4,5] полуичть [1,2]
?- L = [1,2,3,4,5], cat(L1, [_,_,_], L).

Подсписок:
% [__L1__|____S___|___L2____]
subList(S, L) :- cat(_, TMP, L), cat(S, _, TMP).
% ____|__S___
% ____TMP____|_____
% ________L________


shiftLeft([], []).
shiftLeft([X], [X]).
shiftLeft([X | Tail], S) :- cat(Tail, [X], S).
?- shiftLeft([1,2,3], S).
[2,3,1].

shiftLeft([], []).
% shiftLeft([X], [X]).
shiftLeft([X | Tail], S) :- cat(Tail, [X], S).

% rev(Cur, Buf, Res).
rev([], Buf, Buf).
% rev([X], Buf, [Buf | X]). % вызывает дичь..
rev([X | Xs], Buf, Res) :- rev(Xs, [X | Buf], Res).

D = f{a:1, b:2, c:3}.
D = f{a:1, b:2, c:3}, D.a. % выведи D.a
D = 

L = X-Y-Z, X=a, Y=b, Z=c.
L= a-b-c, 
X=a, 
Y=b, 
Z=c.


Д/З: 
https://el.nsu.ru/mod/assign/view.php?id=103033
M-R-P-C
месяц-название реактора-принцип-страна


===============================
===============================
===============================


Семинар 3:
Иногда нужно доказать либо 1, либо 2

P = G1, G2, ... Gk ! G(k+1) ... Gn
P = G1, G2 ! G3, G4
Как я понял: в примере сначала пытаемся доказать G1 и G2, если смогли. G3 и G4 не важны. 




%Вспомним семинар 2:
mem(X, [X | _]).
mem(X, [_ | Tail]) :- mem(X, Tail).

% Наш memberchk, используя так называемый "cut".
mm(X, [X | _]) :- !. % Если true, останавливаем рекурсию. 
mm(X, [_ | Tail]) :- mem(X, Tail).


P :- D1; D2.
% и аналогично
P :- D1.
P :- D2.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is — логическй терм.
% не рекомендуют
is (X, *(2,2)). 
% БАН. Не будет работать, так как в Prolog запрещены неопределённые значения справа -> не решает уравнения.
4 is *(X, 2). 

use_module().
use_module(clpfd). 
% Но так как это стандартная библиотека, обернём в library.
use_module(library(clpfd)). % ищет в своих папках, знает где.

% Добавляются операции сравнения (начинаются с решётки)
?- X #= 2*2
X = 4.

?- 4 #= X*2.
X = 2.

?- X#> 0, X #<= 5.
X in 1..5.